title=TBD
date=2025-02-07
type=post 
tags=opinion, career
status=draft
---------

Four years ago, I wrote my popular blog post so far: [the principal role]. I'm
still surprised when people reach out to me in conferences and ask if I'm the
guy who wrote it.

I've thinking about career paths lately for several reasons. First, I have a
rule of thumb that I should change my job every four years. I love to start new
jobs, learn new things, meet new people... but I also know it takes time to do
those things. Four years is the sweet spot for me. If things don't work out, I
try to stay at least two years. Sometimes, the beginnings are hard and it takes
time to build the trust and the relationships to effectively do your work. New
Relic has been a superb example of that. I never thought in the first two years
I would have the impact I have now.

Second, I've realized I usually change my main technology focus every six years.
This is pure coincidence (is it?), but there's a clear pattern:

- 2001 - 2006: Web development
- 2007 - 2012: Orchestrators (MetaSolv, Oracle OSM)
- 2013 - 2018: API Gateways (Oracle Gatekeeper, Google Apigee)
- 2019 - 2024: Apache Kafka

This year there's a clear swift in my focus to work on Apache Flink. Apache
Kafka is a solved problem at this stage (well, processing 300 million messages
per second never is going to be a solved problem, but you get the idea). Apache
Flink is the next step to improve our pipelines, combining Kafka and Object
Storage, and I'm enjoying to go deep on it. But that's a story for another
post.

Until here, there's nothing new. Getting old means you know yourself better.
This is how I usually operate. But somehow, this time it feels different.

The first big change are LLMs. They are a game changer. For engineers at the
principal level is usually hard to get focus to time for proper coding. Most of
us have a difficult relation with the keyboard. We know we must code, but we
usually have more impact doing other things. And coding is like a muscle, if
you don't use it, you lose it.

LLMs are great because things that I usually wouldn't do because I know I won't
have time to finish them, now I start them in a very casual way. I just ask the
LLM how it would do the most basic implementation to learn about it... and
before I noticed it, I spent two days working on the project. I don't know how
much time I save with them, but it's clear to me that I start projects that I
wouldn't start otherwise. It's also clear that I'm far more productive with
them. I just deliver much more work since I use a LLM in my day-to-day. Most of
the time I know what I want to build and how to build it, the major blocker was
to remember an API a specific syntax or repetitive tasks... and LLMs are great
for that.

The second part is that the data infrastructure world is changing. Open Source
is still winning, but not so much the companies that are behind the projects.
To create software is becoming easier and easier, but to know what software to
build and how to do it is still a big challenge. See the [YCombinator Request
for Startups](https://www.ycombinator.com/rfs/) for example. They are looking
for System engineers to build the next big thing and someone to build the new
Red Hat. At the same time, it seems there's some type of CEO conspiration to
run platform teams understaffed and ask them to do products, including the
frontend.

Something it's clear to me, the fundamentals of software engineering are more
important than ever. The tricks I learned twenty years ago with orchestrators,
still work today with other distributed systems. Debugging, monitoring, and
systems design are still the most important skills to have.


TODO: Conclusion??

 You can reach me on [BlueSky] or [GitHub].

[the principal role]: tbd
[BlueSky]: https://bsky.app/profile/galiglobal.com 
[GitHub]: https://github.com/antonmry/galiglobal/discussions
[YCombinator Request for Startups]: https://www.ycombinator.com/rfs/
