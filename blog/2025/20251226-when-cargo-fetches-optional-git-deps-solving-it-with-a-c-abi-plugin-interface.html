<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8"/>
    <title>When Cargo fetches “optional” Git deps: solving it with a C-ABI plugin interface</title>
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="">
    <meta name="author" content="antonmry">
    <meta name="keywords" content="">
    <meta name="generator" content="generated-from-markdown">

    <link href="/css/bootstrap.min.css" rel="stylesheet">
    <link href="/css/asciidoctor.css" rel="stylesheet">
    <link href="/css/base.css" rel="stylesheet">
    <link href="/css/prettify.css" rel="stylesheet">
  </head>
  <body>
    <div id="wrap">
      <div id="navbar-container"></div>
      <div class="container">
        <div id="content">
        <h1 id="when-cargo-fetches-optional-git-deps-solving-it-with-a-c-abi-plugin-interface">When Cargo fetches “optional” Git deps: solving it with a C-ABI plugin interface</h1>
        <p><em>26 December 2025</em></p>
        <hr>
        <h2 id="the-problem">The problem</h2>
        <p>I've been working on a new public CLI tool. Fascinating project that I can't
        wait to publish. One of things I needed was to reuse some of our backend code
        in the tool itself, but I can't to publish that code at the moment. So what can
        we do?</p>
        <h2 id="naive-approach-and-why-it-fails">Naïve approach and why it fails</h2>
        <p>My first approach was to use a <a href="https://doc.rust-lang.org/cargo/reference/features.html">Cargo
        feature</a> with a
        dependency to <a href="https://doc.rust-lang.org/cargo/reference/specifying-dependencies.html#specifying-dependencies-from-git-repositories">a private git
        repository</a>
        with the crate. We could build internally the tool with that feature, and
        external users could do the same without it. With this approach, I would need
        to add some secrets to our CI systems to download the crate. Not great but
        expected.</p>
        <p>I checked with an LLM this approach and confirmed it was the way go with one
        caveat. We would need an "adapter crate" in the public crate so the dependency
        wasn't direct and the crate wasn't needed when building without the feature
        enabled. Something about this felt wrong but the cost of trying it was low, so
        I did.</p>
        <p>Turns out that this option didn't work at all. The core problem is that Cargo
        may still resolve and fetch Git dependencies even when they are behind disabled
        features, which breaks public builds that don’t have access to private
        repositories. There's <a href="https://github.com/rust-lang/cargo/issues/15834">a GitHub
        issue</a> about it and it seems
        pretty popular.</p>
        <p>When consulting options, the LLM insisted on modifying Cargo.toml in the CI
        system or when an internal user wanted to build with the feature, but that
        options seems a quite ugly workaround. Another option would be to have two
        different Cargo.toml but that's also pretty ugly and keeping both files in sync
        a pain.</p>
        <h2 id="the-workable-solution-runtime-plugin-with-a-c-abi">The workable solution: runtime plugin with a C ABI</h2>
        <p>After a bit of research, I ended evaluating to use a C Application Binary
        Interface (C ABI). This is a pretty interesting Rust feature:</p>
        <p>The private crate is compiled as a runtime plugin
        (<a href="https://doc.rust-lang.org/reference/linkage.html#r-link.cdylib">cdylib</a>) with
        libloading in runtime. With this approach, the CLI will shows the feature only
        if the plugin has been downloaded and it's placed in predefined path.</p>
        <p>This allows users to build the tool without the private dependencies, but also
        have control of what features use. I just added a subcommand <code>plugin</code> to allow
        the user to discover, download and enable plugins. It has also simplified the
        setup: there's no dependency in the CI system except for distribution (if you
        install the CLI via a package mangers, the plugins are also included).</p>
        <p>As usual, it's a trade-off. This approach is less performant (but that's ok for
        this CLI tool) and there are some limitation about what you can pass through
        the ylib boundary safely.</p>
        <p>During the planning phase, the code agent was summarizing the pros and cons and
        I remember myself thinking if this would be a huge rabbit hole on its own. I
        used similar approaches with Java modules in the past, and it was a very useful
        pattern but I wasn't sure how mature would this in Rust Again, I decided to
        give it a try. Any of the alternatives were appealing at all and, at least, I
        would learn about C ABI in Rust.</p>
        <h2 id="implementation-walkthrough">Implementation walkthrough</h2>
        <p>I created a demo implementation in <a href="TODO">my rust-playground git repo</a>. There
        are two crates:</p>
        <ul>
        <li><code>public-cli</code>: a public CLI that loads a plugin if a shared library exists.</li>
        <li><code>private-plugin</code>: a private crate compiled as a <code>cdylib</code> exposing a C-ABI
          function.</li>
        </ul>
        <p>The CLI looks for the plugin next to the executable by default (e.g.
        <code>target/debug/libprivate_plugin.so</code> on Linux,
        <code>target/debug/libprivate_plugin.dylib</code> on macOS,
        <code>target/debug/private_plugin.dll</code> on Windows).</p>
        <p>If you compile and run the CLI:</p>
        <pre class="codehilite"><code class="language-bash">cargo build -p public-cli 
        cargo run -p public-cli
        </code></pre>

        <p>It will print:</p>
        <blockquote>
        <p>running without private feature</p>
        </blockquote>
        <p>If you compile the plugin and because it search for it in the same folder where
        the CLI tool is executed:</p>
        <pre class="codehilite"><code class="language-bash">cargo build -p private-plugin 
        cargo run -p public-cli
        </code></pre>

        <p>It will print:</p>
        <blockquote>
        <p>plugin says: hello from the private plugin</p>
        </blockquote>
        <p>That's it: adding new functionality to the CLI tool without recompiling it.</p>
        <h3 id="the-private-plugin-cdylib">The private plugin (<code>cdylib</code>)</h3>
        <p><code>private-plugin/Cargo.toml</code> declares a <code>cdylib</code> crate type so Rust produces a
        shared library suitable for dynamic loading:</p>
        <pre class="codehilite"><code class="language-toml">[lib]
        crate-type = [&quot;cdylib&quot;]
        </code></pre>

        <p><code>private-plugin/src/lib.rs</code> exposes a single C-ABI symbol:</p>
        <pre class="codehilite"><code class="language-rust">use std::os::raw::c_char;

        #[no_mangle] 
        pub extern &quot;C&quot; fn plugin_message() -&gt; *const c_char { 
            b&quot;hello from the private plugin\0&quot;.as_ptr() as *const c_char 
        }
        </code></pre>

        <p>Notes:</p>
        <ul>
        <li><code>#[no_mangle]</code> keeps the symbol name stable for dynamic loading.</li>
        <li><code>extern "C"</code> gives the C ABI.</li>
        <li>The returned string is a static, NUL-terminated byte string so the CLI can
          read it safely as a <code>CStr</code>.</li>
        </ul>
        <h3 id="the-public-cli-runtime-loading">The public CLI (runtime loading)</h3>
        <p><code>public-cli/src/main.rs</code> looks for the plugin and loads the symbol if found:</p>
        <pre class="codehilite"><code class="language-rust">fn plugin_filename() -&gt; String {
            let base = &quot;private_plugin&quot;;
            let prefix = env::consts::DLL_PREFIX;
            let ext = env::consts::DLL_EXTENSION;
            format!(&quot;{prefix}{base}.{ext}&quot;)
        }
        </code></pre>

        <p>This picks the correct shared library name for the current OS.</p>
        <pre class="codehilite"><code class="language-rust">unsafe {
            let lib = libloading::Library::new(path).map_err(|e| e.to_string())?;
            let func: libloading::Symbol&lt;unsafe extern &quot;C&quot; fn() -&gt; *const c_char&gt; =
                lib.get(b&quot;plugin_message&quot;).map_err(|e| e.to_string())?;
            let ptr = func();
            if ptr.is_null() {
                return Err(&quot;plugin returned null&quot;.to_string());
            }
            let c_str = CStr::from_ptr(ptr);
            let message = c_str.to_string_lossy().into_owned();

            Ok(message)
        }
        </code></pre>

        <p>If the plugin is missing, the CLI prints a fallback message and continues.</p>
        <h2 id="developer-experience">Developer experience</h2>
        <p>The code in my tool is far more complicated. Plugins are published in Object
        Storage and downloaded by the CLI tool. But there's a solid contract between
        the CLI tool and the plugins and that makes things easier. Also, I've created a
        wrapper over the private crates, so they can be imported internally as
        dependencies or externally as plugins. This is convenient to make sure the
        external use doesn't cause any issue.</p>
        <p>What's even better is that now users can easily create their own plugins and
        share them. This isn't a small thing. Modularity is an important piece of
        open-source projects and I'm glad it was so easy and quick to add it to the
        project so soon.</p>
        <h2 id="conclusion">Conclusion</h2>
        <p>I glad I've implemented this pattern. I'm aware this may be overkill and that
        there are issues because Rust types and ABI are unstable across compiler
        versions. But it's perfect for my CLI tool: solved my problem of how to add
        private features to public software and enabled new use cases allowing users to
        extend the functionality without having to build the whole project. Let's see
        how this evolves with time and if I don't regret this approach.</p>
        </div>
        <div id="leaflet-comments" class="mt-4"></div>
      </div>
      <div id="push"></div>
    </div>

    <div id="footer-container"></div>

    <script src="/js/jquery-1.11.1.min.js"></script>
    <script src="/js/bootstrap.min.js" defer></script>
    <script src="/js/prettify.js" defer></script>

    <script>
      async function loadContent(url, elementId) {
        try {
          const response = await fetch(url);
          if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
          const html = await response.text();
          const target = document.getElementById(elementId);
          if (!target) return;
          target.innerHTML = html;

          const scripts = target.querySelectorAll('script[data-execute="true"]');
          scripts.forEach((oldScript) => {
            const newScript = document.createElement('script');
            [...oldScript.attributes].forEach((attr) => newScript.setAttribute(attr.name, attr.value));
            newScript.textContent = oldScript.textContent;
            target.appendChild(newScript);
          });
        } catch (error) {
          console.error(`Error loading ${url}:`, error);
        }
      }

      document.addEventListener('DOMContentLoaded', async () => {
        await loadContent('/navbar.html', 'navbar-container');
        await loadContent('/footer.html', 'footer-container');

        if (typeof prettyPrint === 'function') {
          prettyPrint();
        }
      });
    </script>
  </body>
    </html>
